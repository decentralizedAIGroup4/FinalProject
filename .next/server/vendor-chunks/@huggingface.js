"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@huggingface";
exports.ids = ["vendor-chunks/@huggingface"];
exports.modules = {

/***/ "(rsc)/./node_modules/@huggingface/inference/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@huggingface/inference/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HfInference: () => (/* binding */ HfInference),\n/* harmony export */   HfInferenceEndpoint: () => (/* binding */ HfInferenceEndpoint),\n/* harmony export */   InferenceOutputError: () => (/* binding */ InferenceOutputError),\n/* harmony export */   audioClassification: () => (/* binding */ audioClassification),\n/* harmony export */   audioToAudio: () => (/* binding */ audioToAudio),\n/* harmony export */   automaticSpeechRecognition: () => (/* binding */ automaticSpeechRecognition),\n/* harmony export */   chatCompletion: () => (/* binding */ chatCompletion),\n/* harmony export */   chatCompletionStream: () => (/* binding */ chatCompletionStream),\n/* harmony export */   documentQuestionAnswering: () => (/* binding */ documentQuestionAnswering),\n/* harmony export */   featureExtraction: () => (/* binding */ featureExtraction),\n/* harmony export */   fillMask: () => (/* binding */ fillMask),\n/* harmony export */   imageClassification: () => (/* binding */ imageClassification),\n/* harmony export */   imageSegmentation: () => (/* binding */ imageSegmentation),\n/* harmony export */   imageToImage: () => (/* binding */ imageToImage),\n/* harmony export */   imageToText: () => (/* binding */ imageToText),\n/* harmony export */   objectDetection: () => (/* binding */ objectDetection),\n/* harmony export */   questionAnswering: () => (/* binding */ questionAnswering),\n/* harmony export */   request: () => (/* binding */ request),\n/* harmony export */   sentenceSimilarity: () => (/* binding */ sentenceSimilarity),\n/* harmony export */   streamingRequest: () => (/* binding */ streamingRequest),\n/* harmony export */   summarization: () => (/* binding */ summarization),\n/* harmony export */   tableQuestionAnswering: () => (/* binding */ tableQuestionAnswering),\n/* harmony export */   tabularClassification: () => (/* binding */ tabularClassification),\n/* harmony export */   tabularRegression: () => (/* binding */ tabularRegression),\n/* harmony export */   textClassification: () => (/* binding */ textClassification),\n/* harmony export */   textGeneration: () => (/* binding */ textGeneration),\n/* harmony export */   textGenerationStream: () => (/* binding */ textGenerationStream),\n/* harmony export */   textToImage: () => (/* binding */ textToImage),\n/* harmony export */   textToSpeech: () => (/* binding */ textToSpeech),\n/* harmony export */   tokenClassification: () => (/* binding */ tokenClassification),\n/* harmony export */   translation: () => (/* binding */ translation),\n/* harmony export */   visualQuestionAnswering: () => (/* binding */ visualQuestionAnswering),\n/* harmony export */   zeroShotClassification: () => (/* binding */ zeroShotClassification),\n/* harmony export */   zeroShotImageClassification: () => (/* binding */ zeroShotImageClassification)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/tasks/index.ts\nvar tasks_exports = {};\n__export(tasks_exports, {\n  audioClassification: () => audioClassification,\n  audioToAudio: () => audioToAudio,\n  automaticSpeechRecognition: () => automaticSpeechRecognition,\n  chatCompletion: () => chatCompletion,\n  chatCompletionStream: () => chatCompletionStream,\n  documentQuestionAnswering: () => documentQuestionAnswering,\n  featureExtraction: () => featureExtraction,\n  fillMask: () => fillMask,\n  imageClassification: () => imageClassification,\n  imageSegmentation: () => imageSegmentation,\n  imageToImage: () => imageToImage,\n  imageToText: () => imageToText,\n  objectDetection: () => objectDetection,\n  questionAnswering: () => questionAnswering,\n  request: () => request,\n  sentenceSimilarity: () => sentenceSimilarity,\n  streamingRequest: () => streamingRequest,\n  summarization: () => summarization,\n  tableQuestionAnswering: () => tableQuestionAnswering,\n  tabularClassification: () => tabularClassification,\n  tabularRegression: () => tabularRegression,\n  textClassification: () => textClassification,\n  textGeneration: () => textGeneration,\n  textGenerationStream: () => textGenerationStream,\n  textToImage: () => textToImage,\n  textToSpeech: () => textToSpeech,\n  tokenClassification: () => tokenClassification,\n  translation: () => translation,\n  visualQuestionAnswering: () => visualQuestionAnswering,\n  zeroShotClassification: () => zeroShotClassification,\n  zeroShotImageClassification: () => zeroShotImageClassification\n});\n\n// src/utils/pick.ts\nfunction pick(o, props) {\n  return Object.assign(\n    {},\n    ...props.map((prop) => {\n      if (o[prop] !== void 0) {\n        return { [prop]: o[prop] };\n      }\n    })\n  );\n}\n\n// src/utils/typedInclude.ts\nfunction typedInclude(arr, v) {\n  return arr.includes(v);\n}\n\n// src/utils/omit.ts\nfunction omit(o, props) {\n  const propsArr = Array.isArray(props) ? props : [props];\n  const letsKeep = Object.keys(o).filter((prop) => !typedInclude(propsArr, prop));\n  return pick(o, letsKeep);\n}\n\n// src/lib/isUrl.ts\nfunction isUrl(modelOrUrl) {\n  return /^http(s?):/.test(modelOrUrl) || modelOrUrl.startsWith(\"/\");\n}\n\n// src/lib/getDefaultTask.ts\nvar taskCache = /* @__PURE__ */ new Map();\nvar CACHE_DURATION = 10 * 60 * 1e3;\nvar MAX_CACHE_ITEMS = 1e3;\nvar HF_HUB_URL = \"https://huggingface.co\";\nasync function getDefaultTask(model, accessToken, options) {\n  if (isUrl(model)) {\n    return null;\n  }\n  const key = `${model}:${accessToken}`;\n  let cachedTask = taskCache.get(key);\n  if (cachedTask && cachedTask.date < new Date(Date.now() - CACHE_DURATION)) {\n    taskCache.delete(key);\n    cachedTask = void 0;\n  }\n  if (cachedTask === void 0) {\n    const modelTask = await (options?.fetch ?? fetch)(`${HF_HUB_URL}/api/models/${model}?expand[]=pipeline_tag`, {\n      headers: accessToken ? { Authorization: `Bearer ${accessToken}` } : {}\n    }).then((resp) => resp.json()).then((json) => json.pipeline_tag).catch(() => null);\n    if (!modelTask) {\n      return null;\n    }\n    cachedTask = { task: modelTask, date: /* @__PURE__ */ new Date() };\n    taskCache.set(key, { task: modelTask, date: /* @__PURE__ */ new Date() });\n    if (taskCache.size > MAX_CACHE_ITEMS) {\n      taskCache.delete(taskCache.keys().next().value);\n    }\n  }\n  return cachedTask.task;\n}\n\n// src/lib/makeRequestOptions.ts\nvar HF_INFERENCE_API_BASE_URL = \"https://api-inference.huggingface.co\";\nvar tasks = null;\nasync function makeRequestOptions(args, options) {\n  const { accessToken, endpointUrl, ...otherArgs } = args;\n  let { model } = args;\n  const {\n    forceTask: task,\n    includeCredentials,\n    taskHint,\n    wait_for_model,\n    use_cache,\n    dont_load_model,\n    chatCompletion: chatCompletion2\n  } = options ?? {};\n  const headers = {};\n  if (accessToken) {\n    headers[\"Authorization\"] = `Bearer ${accessToken}`;\n  }\n  if (!model && !tasks && taskHint) {\n    const res = await fetch(`${HF_HUB_URL}/api/tasks`);\n    if (res.ok) {\n      tasks = await res.json();\n    }\n  }\n  if (!model && tasks && taskHint) {\n    const taskInfo = tasks[taskHint];\n    if (taskInfo) {\n      model = taskInfo.models[0].id;\n    }\n  }\n  if (!model) {\n    throw new Error(\"No model provided, and no default model found for this task\");\n  }\n  const binary = \"data\" in args && !!args.data;\n  if (!binary) {\n    headers[\"Content-Type\"] = \"application/json\";\n  }\n  if (wait_for_model) {\n    headers[\"X-Wait-For-Model\"] = \"true\";\n  }\n  if (use_cache === false) {\n    headers[\"X-Use-Cache\"] = \"false\";\n  }\n  if (dont_load_model) {\n    headers[\"X-Load-Model\"] = \"0\";\n  }\n  let url = (() => {\n    if (endpointUrl && isUrl(model)) {\n      throw new TypeError(\"Both model and endpointUrl cannot be URLs\");\n    }\n    if (isUrl(model)) {\n      console.warn(\"Using a model URL is deprecated, please use the `endpointUrl` parameter instead\");\n      return model;\n    }\n    if (endpointUrl) {\n      return endpointUrl;\n    }\n    if (task) {\n      return `${HF_INFERENCE_API_BASE_URL}/pipeline/${task}/${model}`;\n    }\n    return `${HF_INFERENCE_API_BASE_URL}/models/${model}`;\n  })();\n  if (chatCompletion2 && !url.endsWith(\"/chat/completions\")) {\n    url += \"/v1/chat/completions\";\n  }\n  let credentials;\n  if (typeof includeCredentials === \"string\") {\n    credentials = includeCredentials;\n  } else if (includeCredentials === true) {\n    credentials = \"include\";\n  }\n  const info = {\n    headers,\n    method: \"POST\",\n    body: binary ? args.data : JSON.stringify({\n      ...otherArgs.model && isUrl(otherArgs.model) ? omit(otherArgs, \"model\") : otherArgs\n    }),\n    ...credentials && { credentials },\n    signal: options?.signal\n  };\n  return { url, info };\n}\n\n// src/tasks/custom/request.ts\nasync function request(args, options) {\n  const { url, info } = await makeRequestOptions(args, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return request(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n      }\n      if (output.error) {\n        throw new Error(JSON.stringify(output.error));\n      }\n    }\n    throw new Error(\"An error occurred while fetching the blob\");\n  }\n  if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  return await response.blob();\n}\n\n// src/vendor/fetch-event-source/parse.ts\nfunction getLines(onLine) {\n  let buffer;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === void 0) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0;\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* NewLine */) {\n          lineStart = ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineEnd = -1;\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* Colon */:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n            break;\n          case 13 /* CarriageReturn */:\n            discardTrailingNewline = true;\n          case 10 /* NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        break;\n      }\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = void 0;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId(message.id = value);\n          break;\n        case \"retry\":\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n          break;\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: void 0\n  };\n}\n\n// src/tasks/custom/streamingRequest.ts\nasync function* streamingRequest(args, options) {\n  const { url, info } = await makeRequestOptions({ ...args, stream: true }, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return yield* streamingRequest(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n      }\n      if (output.error) {\n        throw new Error(output.error);\n      }\n    }\n    throw new Error(`Server response contains error: ${response.status}`);\n  }\n  if (!response.headers.get(\"content-type\")?.startsWith(\"text/event-stream\")) {\n    throw new Error(\n      `Server does not support event stream content type, it returned ` + response.headers.get(\"content-type\")\n    );\n  }\n  if (!response.body) {\n    return;\n  }\n  const reader = response.body.getReader();\n  let events = [];\n  const onEvent = (event) => {\n    events.push(event);\n  };\n  const onChunk = getLines(\n    getMessages(\n      () => {\n      },\n      () => {\n      },\n      onEvent\n    )\n  );\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done)\n        return;\n      onChunk(value);\n      for (const event of events) {\n        if (event.data.length > 0) {\n          if (event.data === \"[DONE]\") {\n            return;\n          }\n          const data = JSON.parse(event.data);\n          if (typeof data === \"object\" && data !== null && \"error\" in data) {\n            throw new Error(data.error);\n          }\n          yield data;\n        }\n      }\n      events = [];\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/lib/InferenceOutputError.ts\nvar InferenceOutputError = class extends TypeError {\n  constructor(message) {\n    super(\n      `Invalid inference output: ${message}. Use the 'request' method with the same parameters to do a custom call with no type checking.`\n    );\n    this.name = \"InferenceOutputError\";\n  }\n};\n\n// src/tasks/audio/audioClassification.ts\nasync function audioClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/audio/automaticSpeechRecognition.ts\nasync function automaticSpeechRecognition(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"automatic-speech-recognition\"\n  });\n  const isValidOutput = typeof res?.text === \"string\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/audio/textToSpeech.ts\nasync function textToSpeech(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-speech\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/audio/audioToAudio.ts\nasync function audioToAudio(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-to-audio\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.label === \"string\" && typeof x.blob === \"string\" && typeof x[\"content-type\"] === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, blob: string, content-type: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageClassification.ts\nasync function imageClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageSegmentation.ts\nasync function imageSegmentation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-segmentation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.mask === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, mask: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageToText.ts\nasync function imageToText(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"image-to-text\"\n  }))?.[0];\n  if (typeof res?.generated_text !== \"string\") {\n    throw new InferenceOutputError(\"Expected {generated_text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/cv/objectDetection.ts\nasync function objectDetection(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"object-detection\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/cv/textToImage.ts\nasync function textToImage(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/utils/base64FromBytes.ts\nfunction base64FromBytes(arr) {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.from(arr).toString(\"base64\");\n  } else {\n    const bin = [];\n    arr.forEach((byte) => {\n      bin.push(String.fromCharCode(byte));\n    });\n    return globalThis.btoa(bin.join(\"\"));\n  }\n}\n\n// src/tasks/cv/imageToImage.ts\nasync function imageToImage(args, options) {\n  let reqArgs;\n  if (!args.parameters) {\n    reqArgs = {\n      accessToken: args.accessToken,\n      model: args.model,\n      data: args.inputs\n    };\n  } else {\n    reqArgs = {\n      ...args,\n      inputs: base64FromBytes(\n        new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer())\n      )\n    };\n  }\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"image-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/cv/zeroShotImageClassification.ts\nasync function zeroShotImageClassification(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"zero-shot-image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/featureExtraction.ts\nasync function featureExtraction(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"feature-extraction\",\n    ...defaultTask === \"sentence-similarity\" && { forceTask: \"feature-extraction\" }\n  });\n  let isValidOutput = true;\n  const isNumArrayRec = (arr, maxDepth, curDepth = 0) => {\n    if (curDepth > maxDepth)\n      return false;\n    if (arr.every((x) => Array.isArray(x))) {\n      return arr.every((x) => isNumArrayRec(x, maxDepth, curDepth + 1));\n    } else {\n      return arr.every((x) => typeof x === \"number\");\n    }\n  };\n  isValidOutput = Array.isArray(res) && isNumArrayRec(res, 3, 0);\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<number[][][] | number[][] | number[] | number>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/fillMask.ts\nasync function fillMask(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"fill-mask\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{score: number, sequence: string, token: number, token_str: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/questionAnswering.ts\nasync function questionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"question-answering\"\n  });\n  const isValidOutput = typeof res === \"object\" && !!res && typeof res.answer === \"string\" && typeof res.end === \"number\" && typeof res.score === \"number\" && typeof res.start === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {answer: string, end: number, score: number, start: number}\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/sentenceSimilarity.ts\nasync function sentenceSimilarity(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"sentence-similarity\",\n    ...defaultTask === \"feature-extraction\" && { forceTask: \"sentence-similarity\" }\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/summarization.ts\nasync function summarization(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"summarization\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.summary_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{summary_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/tableQuestionAnswering.ts\nasync function tableQuestionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"table-question-answering\"\n  });\n  const isValidOutput = typeof res?.aggregator === \"string\" && typeof res.answer === \"string\" && Array.isArray(res.cells) && res.cells.every((x) => typeof x === \"string\") && Array.isArray(res.coordinates) && res.coordinates.every((coord) => Array.isArray(coord) && coord.every((x) => typeof x === \"number\"));\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/textClassification.ts\nasync function textClassification(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"text-classification\"\n  }))?.[0];\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/utils/toArray.ts\nfunction toArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\n// src/tasks/nlp/textGeneration.ts\nasync function textGeneration(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"text-generation\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.generated_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{generated_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/textGenerationStream.ts\nasync function* textGenerationStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\"\n  });\n}\n\n// src/tasks/nlp/tokenClassification.ts\nasync function tokenClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"token-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/translation.ts\nasync function translation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"translation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.translation_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected type Array<{translation_text: string}>\");\n  }\n  return res?.length === 1 ? res?.[0] : res;\n}\n\n// src/tasks/nlp/zeroShotClassification.ts\nasync function zeroShotClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"zero-shot-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => Array.isArray(x.labels) && x.labels.every((_label) => typeof _label === \"string\") && Array.isArray(x.scores) && x.scores.every((_score) => typeof _score === \"number\") && typeof x.sequence === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{labels: string[], scores: number[], sequence: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletion.ts\nasync function chatCompletion(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n  const isValidOutput = typeof res === \"object\" && Array.isArray(res?.choices) && typeof res?.created === \"number\" && typeof res?.id === \"string\" && typeof res?.model === \"string\" && typeof res?.system_fingerprint === \"string\" && typeof res?.usage === \"object\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletionStream.ts\nasync function* chatCompletionStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n}\n\n// src/tasks/multimodal/documentQuestionAnswering.ts\nasync function documentQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = toArray(\n    await request(reqArgs, {\n      ...options,\n      taskHint: \"document-question-answering\"\n    })\n  )?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && (typeof res.end === \"number\" || typeof res.end === \"undefined\") && (typeof res.score === \"number\" || typeof res.score === \"undefined\") && (typeof res.start === \"number\" || typeof res.start === \"undefined\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, end?: number, score?: number, start?: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/multimodal/visualQuestionAnswering.ts\nasync function visualQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = (await request(reqArgs, {\n    ...options,\n    taskHint: \"visual-question-answering\"\n  }))?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && typeof res.score === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularRegression.ts\nasync function tabularRegression(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-regression\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularClassification.ts\nasync function tabularClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/HfInference.ts\nvar HfInference = class {\n  accessToken;\n  defaultOptions;\n  constructor(accessToken = \"\", defaultOptions = {}) {\n    this.accessToken = accessToken;\n    this.defaultOptions = defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n  /**\n   * Returns copy of HfInference tied to a specified endpoint.\n   */\n  endpoint(endpointUrl) {\n    return new HfInferenceEndpoint(endpointUrl, this.accessToken, this.defaultOptions);\n  }\n};\nvar HfInferenceEndpoint = class {\n  constructor(endpointUrl, accessToken = \"\", defaultOptions = {}) {\n    accessToken;\n    defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken, endpointUrl }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGh1Z2dpbmdmYWNlL2luZmVyZW5jZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTSxHQUFHLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVcsY0FBYyxNQUFNO0FBQ3hGLCtCQUErQix5QkFBeUIsWUFBWSxJQUFJO0FBQ3hFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIseUJBQXlCLG1EQUFtRDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlDQUF5QztBQUNuRCxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBLCtCQUEr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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDLElBQUksK0JBQStCO0FBQ3ZGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQW9DRSIsInNvdXJjZXMiOlsiL2hvbWUvYnJlbnQvRG93bmxvYWRzL0VuY29kZURFQUkvRmluYWxQcm9qZWN0L25vZGVfbW9kdWxlcy9AaHVnZ2luZ2ZhY2UvaW5mZXJlbmNlL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL3Rhc2tzL2luZGV4LnRzXG52YXIgdGFza3NfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodGFza3NfZXhwb3J0cywge1xuICBhdWRpb0NsYXNzaWZpY2F0aW9uOiAoKSA9PiBhdWRpb0NsYXNzaWZpY2F0aW9uLFxuICBhdWRpb1RvQXVkaW86ICgpID0+IGF1ZGlvVG9BdWRpbyxcbiAgYXV0b21hdGljU3BlZWNoUmVjb2duaXRpb246ICgpID0+IGF1dG9tYXRpY1NwZWVjaFJlY29nbml0aW9uLFxuICBjaGF0Q29tcGxldGlvbjogKCkgPT4gY2hhdENvbXBsZXRpb24sXG4gIGNoYXRDb21wbGV0aW9uU3RyZWFtOiAoKSA9PiBjaGF0Q29tcGxldGlvblN0cmVhbSxcbiAgZG9jdW1lbnRRdWVzdGlvbkFuc3dlcmluZzogKCkgPT4gZG9jdW1lbnRRdWVzdGlvbkFuc3dlcmluZyxcbiAgZmVhdHVyZUV4dHJhY3Rpb246ICgpID0+IGZlYXR1cmVFeHRyYWN0aW9uLFxuICBmaWxsTWFzazogKCkgPT4gZmlsbE1hc2ssXG4gIGltYWdlQ2xhc3NpZmljYXRpb246ICgpID0+IGltYWdlQ2xhc3NpZmljYXRpb24sXG4gIGltYWdlU2VnbWVudGF0aW9uOiAoKSA9PiBpbWFnZVNlZ21lbnRhdGlvbixcbiAgaW1hZ2VUb0ltYWdlOiAoKSA9PiBpbWFnZVRvSW1hZ2UsXG4gIGltYWdlVG9UZXh0OiAoKSA9PiBpbWFnZVRvVGV4dCxcbiAgb2JqZWN0RGV0ZWN0aW9uOiAoKSA9PiBvYmplY3REZXRlY3Rpb24sXG4gIHF1ZXN0aW9uQW5zd2VyaW5nOiAoKSA9PiBxdWVzdGlvbkFuc3dlcmluZyxcbiAgcmVxdWVzdDogKCkgPT4gcmVxdWVzdCxcbiAgc2VudGVuY2VTaW1pbGFyaXR5OiAoKSA9PiBzZW50ZW5jZVNpbWlsYXJpdHksXG4gIHN0cmVhbWluZ1JlcXVlc3Q6ICgpID0+IHN0cmVhbWluZ1JlcXVlc3QsXG4gIHN1bW1hcml6YXRpb246ICgpID0+IHN1bW1hcml6YXRpb24sXG4gIHRhYmxlUXVlc3Rpb25BbnN3ZXJpbmc6ICgpID0+IHRhYmxlUXVlc3Rpb25BbnN3ZXJpbmcsXG4gIHRhYnVsYXJDbGFzc2lmaWNhdGlvbjogKCkgPT4gdGFidWxhckNsYXNzaWZpY2F0aW9uLFxuICB0YWJ1bGFyUmVncmVzc2lvbjogKCkgPT4gdGFidWxhclJlZ3Jlc3Npb24sXG4gIHRleHRDbGFzc2lmaWNhdGlvbjogKCkgPT4gdGV4dENsYXNzaWZpY2F0aW9uLFxuICB0ZXh0R2VuZXJhdGlvbjogKCkgPT4gdGV4dEdlbmVyYXRpb24sXG4gIHRleHRHZW5lcmF0aW9uU3RyZWFtOiAoKSA9PiB0ZXh0R2VuZXJhdGlvblN0cmVhbSxcbiAgdGV4dFRvSW1hZ2U6ICgpID0+IHRleHRUb0ltYWdlLFxuICB0ZXh0VG9TcGVlY2g6ICgpID0+IHRleHRUb1NwZWVjaCxcbiAgdG9rZW5DbGFzc2lmaWNhdGlvbjogKCkgPT4gdG9rZW5DbGFzc2lmaWNhdGlvbixcbiAgdHJhbnNsYXRpb246ICgpID0+IHRyYW5zbGF0aW9uLFxuICB2aXN1YWxRdWVzdGlvbkFuc3dlcmluZzogKCkgPT4gdmlzdWFsUXVlc3Rpb25BbnN3ZXJpbmcsXG4gIHplcm9TaG90Q2xhc3NpZmljYXRpb246ICgpID0+IHplcm9TaG90Q2xhc3NpZmljYXRpb24sXG4gIHplcm9TaG90SW1hZ2VDbGFzc2lmaWNhdGlvbjogKCkgPT4gemVyb1Nob3RJbWFnZUNsYXNzaWZpY2F0aW9uXG59KTtcblxuLy8gc3JjL3V0aWxzL3BpY2sudHNcbmZ1bmN0aW9uIHBpY2sobywgcHJvcHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAge30sXG4gICAgLi4ucHJvcHMubWFwKChwcm9wKSA9PiB7XG4gICAgICBpZiAob1twcm9wXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IFtwcm9wXTogb1twcm9wXSB9O1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy90eXBlZEluY2x1ZGUudHNcbmZ1bmN0aW9uIHR5cGVkSW5jbHVkZShhcnIsIHYpIHtcbiAgcmV0dXJuIGFyci5pbmNsdWRlcyh2KTtcbn1cblxuLy8gc3JjL3V0aWxzL29taXQudHNcbmZ1bmN0aW9uIG9taXQobywgcHJvcHMpIHtcbiAgY29uc3QgcHJvcHNBcnIgPSBBcnJheS5pc0FycmF5KHByb3BzKSA/IHByb3BzIDogW3Byb3BzXTtcbiAgY29uc3QgbGV0c0tlZXAgPSBPYmplY3Qua2V5cyhvKS5maWx0ZXIoKHByb3ApID0+ICF0eXBlZEluY2x1ZGUocHJvcHNBcnIsIHByb3ApKTtcbiAgcmV0dXJuIHBpY2sobywgbGV0c0tlZXApO1xufVxuXG4vLyBzcmMvbGliL2lzVXJsLnRzXG5mdW5jdGlvbiBpc1VybChtb2RlbE9yVXJsKSB7XG4gIHJldHVybiAvXmh0dHAocz8pOi8udGVzdChtb2RlbE9yVXJsKSB8fCBtb2RlbE9yVXJsLnN0YXJ0c1dpdGgoXCIvXCIpO1xufVxuXG4vLyBzcmMvbGliL2dldERlZmF1bHRUYXNrLnRzXG52YXIgdGFza0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciBDQUNIRV9EVVJBVElPTiA9IDEwICogNjAgKiAxZTM7XG52YXIgTUFYX0NBQ0hFX0lURU1TID0gMWUzO1xudmFyIEhGX0hVQl9VUkwgPSBcImh0dHBzOi8vaHVnZ2luZ2ZhY2UuY29cIjtcbmFzeW5jIGZ1bmN0aW9uIGdldERlZmF1bHRUYXNrKG1vZGVsLCBhY2Nlc3NUb2tlbiwgb3B0aW9ucykge1xuICBpZiAoaXNVcmwobW9kZWwpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qga2V5ID0gYCR7bW9kZWx9OiR7YWNjZXNzVG9rZW59YDtcbiAgbGV0IGNhY2hlZFRhc2sgPSB0YXNrQ2FjaGUuZ2V0KGtleSk7XG4gIGlmIChjYWNoZWRUYXNrICYmIGNhY2hlZFRhc2suZGF0ZSA8IG5ldyBEYXRlKERhdGUubm93KCkgLSBDQUNIRV9EVVJBVElPTikpIHtcbiAgICB0YXNrQ2FjaGUuZGVsZXRlKGtleSk7XG4gICAgY2FjaGVkVGFzayA9IHZvaWQgMDtcbiAgfVxuICBpZiAoY2FjaGVkVGFzayA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgbW9kZWxUYXNrID0gYXdhaXQgKG9wdGlvbnM/LmZldGNoID8/IGZldGNoKShgJHtIRl9IVUJfVVJMfS9hcGkvbW9kZWxzLyR7bW9kZWx9P2V4cGFuZFtdPXBpcGVsaW5lX3RhZ2AsIHtcbiAgICAgIGhlYWRlcnM6IGFjY2Vzc1Rva2VuID8geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCB9IDoge31cbiAgICB9KS50aGVuKChyZXNwKSA9PiByZXNwLmpzb24oKSkudGhlbigoanNvbikgPT4ganNvbi5waXBlbGluZV90YWcpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgIGlmICghbW9kZWxUYXNrKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY2FjaGVkVGFzayA9IHsgdGFzazogbW9kZWxUYXNrLCBkYXRlOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSB9O1xuICAgIHRhc2tDYWNoZS5zZXQoa2V5LCB7IHRhc2s6IG1vZGVsVGFzaywgZGF0ZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkgfSk7XG4gICAgaWYgKHRhc2tDYWNoZS5zaXplID4gTUFYX0NBQ0hFX0lURU1TKSB7XG4gICAgICB0YXNrQ2FjaGUuZGVsZXRlKHRhc2tDYWNoZS5rZXlzKCkubmV4dCgpLnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhY2hlZFRhc2sudGFzaztcbn1cblxuLy8gc3JjL2xpYi9tYWtlUmVxdWVzdE9wdGlvbnMudHNcbnZhciBIRl9JTkZFUkVOQ0VfQVBJX0JBU0VfVVJMID0gXCJodHRwczovL2FwaS1pbmZlcmVuY2UuaHVnZ2luZ2ZhY2UuY29cIjtcbnZhciB0YXNrcyA9IG51bGw7XG5hc3luYyBmdW5jdGlvbiBtYWtlUmVxdWVzdE9wdGlvbnMoYXJncywgb3B0aW9ucykge1xuICBjb25zdCB7IGFjY2Vzc1Rva2VuLCBlbmRwb2ludFVybCwgLi4ub3RoZXJBcmdzIH0gPSBhcmdzO1xuICBsZXQgeyBtb2RlbCB9ID0gYXJncztcbiAgY29uc3Qge1xuICAgIGZvcmNlVGFzazogdGFzayxcbiAgICBpbmNsdWRlQ3JlZGVudGlhbHMsXG4gICAgdGFza0hpbnQsXG4gICAgd2FpdF9mb3JfbW9kZWwsXG4gICAgdXNlX2NhY2hlLFxuICAgIGRvbnRfbG9hZF9tb2RlbCxcbiAgICBjaGF0Q29tcGxldGlvbjogY2hhdENvbXBsZXRpb24yXG4gIH0gPSBvcHRpb25zID8/IHt9O1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGlmIChhY2Nlc3NUb2tlbikge1xuICAgIGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gYEJlYXJlciAke2FjY2Vzc1Rva2VufWA7XG4gIH1cbiAgaWYgKCFtb2RlbCAmJiAhdGFza3MgJiYgdGFza0hpbnQpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtIRl9IVUJfVVJMfS9hcGkvdGFza3NgKTtcbiAgICBpZiAocmVzLm9rKSB7XG4gICAgICB0YXNrcyA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgfVxuICB9XG4gIGlmICghbW9kZWwgJiYgdGFza3MgJiYgdGFza0hpbnQpIHtcbiAgICBjb25zdCB0YXNrSW5mbyA9IHRhc2tzW3Rhc2tIaW50XTtcbiAgICBpZiAodGFza0luZm8pIHtcbiAgICAgIG1vZGVsID0gdGFza0luZm8ubW9kZWxzWzBdLmlkO1xuICAgIH1cbiAgfVxuICBpZiAoIW1vZGVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbW9kZWwgcHJvdmlkZWQsIGFuZCBubyBkZWZhdWx0IG1vZGVsIGZvdW5kIGZvciB0aGlzIHRhc2tcIik7XG4gIH1cbiAgY29uc3QgYmluYXJ5ID0gXCJkYXRhXCIgaW4gYXJncyAmJiAhIWFyZ3MuZGF0YTtcbiAgaWYgKCFiaW5hcnkpIHtcbiAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gIH1cbiAgaWYgKHdhaXRfZm9yX21vZGVsKSB7XG4gICAgaGVhZGVyc1tcIlgtV2FpdC1Gb3ItTW9kZWxcIl0gPSBcInRydWVcIjtcbiAgfVxuICBpZiAodXNlX2NhY2hlID09PSBmYWxzZSkge1xuICAgIGhlYWRlcnNbXCJYLVVzZS1DYWNoZVwiXSA9IFwiZmFsc2VcIjtcbiAgfVxuICBpZiAoZG9udF9sb2FkX21vZGVsKSB7XG4gICAgaGVhZGVyc1tcIlgtTG9hZC1Nb2RlbFwiXSA9IFwiMFwiO1xuICB9XG4gIGxldCB1cmwgPSAoKCkgPT4ge1xuICAgIGlmIChlbmRwb2ludFVybCAmJiBpc1VybChtb2RlbCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJCb3RoIG1vZGVsIGFuZCBlbmRwb2ludFVybCBjYW5ub3QgYmUgVVJMc1wiKTtcbiAgICB9XG4gICAgaWYgKGlzVXJsKG1vZGVsKSkge1xuICAgICAgY29uc29sZS53YXJuKFwiVXNpbmcgYSBtb2RlbCBVUkwgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0aGUgYGVuZHBvaW50VXJsYCBwYXJhbWV0ZXIgaW5zdGVhZFwiKTtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG4gICAgaWYgKGVuZHBvaW50VXJsKSB7XG4gICAgICByZXR1cm4gZW5kcG9pbnRVcmw7XG4gICAgfVxuICAgIGlmICh0YXNrKSB7XG4gICAgICByZXR1cm4gYCR7SEZfSU5GRVJFTkNFX0FQSV9CQVNFX1VSTH0vcGlwZWxpbmUvJHt0YXNrfS8ke21vZGVsfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtIRl9JTkZFUkVOQ0VfQVBJX0JBU0VfVVJMfS9tb2RlbHMvJHttb2RlbH1gO1xuICB9KSgpO1xuICBpZiAoY2hhdENvbXBsZXRpb24yICYmICF1cmwuZW5kc1dpdGgoXCIvY2hhdC9jb21wbGV0aW9uc1wiKSkge1xuICAgIHVybCArPSBcIi92MS9jaGF0L2NvbXBsZXRpb25zXCI7XG4gIH1cbiAgbGV0IGNyZWRlbnRpYWxzO1xuICBpZiAodHlwZW9mIGluY2x1ZGVDcmVkZW50aWFscyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNyZWRlbnRpYWxzID0gaW5jbHVkZUNyZWRlbnRpYWxzO1xuICB9IGVsc2UgaWYgKGluY2x1ZGVDcmVkZW50aWFscyA9PT0gdHJ1ZSkge1xuICAgIGNyZWRlbnRpYWxzID0gXCJpbmNsdWRlXCI7XG4gIH1cbiAgY29uc3QgaW5mbyA9IHtcbiAgICBoZWFkZXJzLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogYmluYXJ5ID8gYXJncy5kYXRhIDogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgLi4ub3RoZXJBcmdzLm1vZGVsICYmIGlzVXJsKG90aGVyQXJncy5tb2RlbCkgPyBvbWl0KG90aGVyQXJncywgXCJtb2RlbFwiKSA6IG90aGVyQXJnc1xuICAgIH0pLFxuICAgIC4uLmNyZWRlbnRpYWxzICYmIHsgY3JlZGVudGlhbHMgfSxcbiAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbFxuICB9O1xuICByZXR1cm4geyB1cmwsIGluZm8gfTtcbn1cblxuLy8gc3JjL3Rhc2tzL2N1c3RvbS9yZXF1ZXN0LnRzXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0KGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyB1cmwsIGluZm8gfSA9IGF3YWl0IG1ha2VSZXF1ZXN0T3B0aW9ucyhhcmdzLCBvcHRpb25zKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAob3B0aW9ucz8uZmV0Y2ggPz8gZmV0Y2gpKHVybCwgaW5mbyk7XG4gIGlmIChvcHRpb25zPy5yZXRyeV9vbl9lcnJvciAhPT0gZmFsc2UgJiYgcmVzcG9uc2Uuc3RhdHVzID09PSA1MDMgJiYgIW9wdGlvbnM/LndhaXRfZm9yX21vZGVsKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QoYXJncywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHdhaXRfZm9yX21vZGVsOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKT8uc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGlmIChbNDAwLCA0MjIsIDQwNCwgNTAwXS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpICYmIG9wdGlvbnM/LmNoYXRDb21wbGV0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyICR7YXJncy5tb2RlbH0gZG9lcyBub3Qgc2VlbSB0byBzdXBwb3J0IGNoYXQgY29tcGxldGlvbi4gRXJyb3I6ICR7b3V0cHV0LmVycm9yfWApO1xuICAgICAgfVxuICAgICAgaWYgKG91dHB1dC5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkob3V0cHV0LmVycm9yKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIHRoZSBibG9iXCIpO1xuICB9XG4gIGlmIChyZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKT8uc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIHJldHVybiBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG59XG5cbi8vIHNyYy92ZW5kb3IvZmV0Y2gtZXZlbnQtc291cmNlL3BhcnNlLnRzXG5mdW5jdGlvbiBnZXRMaW5lcyhvbkxpbmUpIHtcbiAgbGV0IGJ1ZmZlcjtcbiAgbGV0IHBvc2l0aW9uO1xuICBsZXQgZmllbGRMZW5ndGg7XG4gIGxldCBkaXNjYXJkVHJhaWxpbmdOZXdsaW5lID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiBvbkNodW5rKGFycikge1xuICAgIGlmIChidWZmZXIgPT09IHZvaWQgMCkge1xuICAgICAgYnVmZmVyID0gYXJyO1xuICAgICAgcG9zaXRpb24gPSAwO1xuICAgICAgZmllbGRMZW5ndGggPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyID0gY29uY2F0KGJ1ZmZlciwgYXJyKTtcbiAgICB9XG4gICAgY29uc3QgYnVmTGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICBsZXQgbGluZVN0YXJ0ID0gMDtcbiAgICB3aGlsZSAocG9zaXRpb24gPCBidWZMZW5ndGgpIHtcbiAgICAgIGlmIChkaXNjYXJkVHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICAgIGlmIChidWZmZXJbcG9zaXRpb25dID09PSAxMCAvKiBOZXdMaW5lICovKSB7XG4gICAgICAgICAgbGluZVN0YXJ0ID0gKytwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBkaXNjYXJkVHJhaWxpbmdOZXdsaW5lID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgbGluZUVuZCA9IC0xO1xuICAgICAgZm9yICg7IHBvc2l0aW9uIDwgYnVmTGVuZ3RoICYmIGxpbmVFbmQgPT09IC0xOyArK3Bvc2l0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAoYnVmZmVyW3Bvc2l0aW9uXSkge1xuICAgICAgICAgIGNhc2UgNTggLyogQ29sb24gKi86XG4gICAgICAgICAgICBpZiAoZmllbGRMZW5ndGggPT09IC0xKSB7XG4gICAgICAgICAgICAgIGZpZWxkTGVuZ3RoID0gcG9zaXRpb24gLSBsaW5lU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzIC8qIENhcnJpYWdlUmV0dXJuICovOlxuICAgICAgICAgICAgZGlzY2FyZFRyYWlsaW5nTmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgY2FzZSAxMCAvKiBOZXdMaW5lICovOlxuICAgICAgICAgICAgbGluZUVuZCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsaW5lRW5kID09PSAtMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9uTGluZShidWZmZXIuc3ViYXJyYXkobGluZVN0YXJ0LCBsaW5lRW5kKSwgZmllbGRMZW5ndGgpO1xuICAgICAgbGluZVN0YXJ0ID0gcG9zaXRpb247XG4gICAgICBmaWVsZExlbmd0aCA9IC0xO1xuICAgIH1cbiAgICBpZiAobGluZVN0YXJ0ID09PSBidWZMZW5ndGgpIHtcbiAgICAgIGJ1ZmZlciA9IHZvaWQgMDtcbiAgICB9IGVsc2UgaWYgKGxpbmVTdGFydCAhPT0gMCkge1xuICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KGxpbmVTdGFydCk7XG4gICAgICBwb3NpdGlvbiAtPSBsaW5lU3RhcnQ7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZXMob25JZCwgb25SZXRyeSwgb25NZXNzYWdlKSB7XG4gIGxldCBtZXNzYWdlID0gbmV3TWVzc2FnZSgpO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIHJldHVybiBmdW5jdGlvbiBvbkxpbmUobGluZSwgZmllbGRMZW5ndGgpIHtcbiAgICBpZiAobGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgIG9uTWVzc2FnZT8uKG1lc3NhZ2UpO1xuICAgICAgbWVzc2FnZSA9IG5ld01lc3NhZ2UoKTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkTGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmllbGQgPSBkZWNvZGVyLmRlY29kZShsaW5lLnN1YmFycmF5KDAsIGZpZWxkTGVuZ3RoKSk7XG4gICAgICBjb25zdCB2YWx1ZU9mZnNldCA9IGZpZWxkTGVuZ3RoICsgKGxpbmVbZmllbGRMZW5ndGggKyAxXSA9PT0gMzIgLyogU3BhY2UgKi8gPyAyIDogMSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGRlY29kZXIuZGVjb2RlKGxpbmUuc3ViYXJyYXkodmFsdWVPZmZzZXQpKTtcbiAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICBtZXNzYWdlLmRhdGEgPSBtZXNzYWdlLmRhdGEgPyBtZXNzYWdlLmRhdGEgKyBcIlxcblwiICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgbWVzc2FnZS5ldmVudCA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICBvbklkKG1lc3NhZ2UuaWQgPSB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZXRyeVwiOlxuICAgICAgICAgIGNvbnN0IHJldHJ5ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHJldHJ5KSkge1xuICAgICAgICAgICAgb25SZXRyeShtZXNzYWdlLnJldHJ5ID0gcmV0cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjb25jYXQoYSwgYikge1xuICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCArIGIubGVuZ3RoKTtcbiAgcmVzLnNldChhKTtcbiAgcmVzLnNldChiLCBhLmxlbmd0aCk7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBuZXdNZXNzYWdlKCkge1xuICByZXR1cm4ge1xuICAgIGRhdGE6IFwiXCIsXG4gICAgZXZlbnQ6IFwiXCIsXG4gICAgaWQ6IFwiXCIsXG4gICAgcmV0cnk6IHZvaWQgMFxuICB9O1xufVxuXG4vLyBzcmMvdGFza3MvY3VzdG9tL3N0cmVhbWluZ1JlcXVlc3QudHNcbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1pbmdSZXF1ZXN0KGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyB1cmwsIGluZm8gfSA9IGF3YWl0IG1ha2VSZXF1ZXN0T3B0aW9ucyh7IC4uLmFyZ3MsIHN0cmVhbTogdHJ1ZSB9LCBvcHRpb25zKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAob3B0aW9ucz8uZmV0Y2ggPz8gZmV0Y2gpKHVybCwgaW5mbyk7XG4gIGlmIChvcHRpb25zPy5yZXRyeV9vbl9lcnJvciAhPT0gZmFsc2UgJiYgcmVzcG9uc2Uuc3RhdHVzID09PSA1MDMgJiYgIW9wdGlvbnM/LndhaXRfZm9yX21vZGVsKSB7XG4gICAgcmV0dXJuIHlpZWxkKiBzdHJlYW1pbmdSZXF1ZXN0KGFyZ3MsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB3YWl0X2Zvcl9tb2RlbDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBpZiAocmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik/LnN0YXJ0c1dpdGgoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBpZiAoWzQwMCwgNDIyLCA0MDQsIDUwMF0uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSAmJiBvcHRpb25zPy5jaGF0Q29tcGxldGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciAke2FyZ3MubW9kZWx9IGRvZXMgbm90IHNlZW0gdG8gc3VwcG9ydCBjaGF0IGNvbXBsZXRpb24uIEVycm9yOiAke291dHB1dC5lcnJvcn1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdXRwdXQuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG91dHB1dC5lcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJlc3BvbnNlIGNvbnRhaW5zIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgfVxuICBpZiAoIXJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpPy5zdGFydHNXaXRoKFwidGV4dC9ldmVudC1zdHJlYW1cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgZXZlbnQgc3RyZWFtIGNvbnRlbnQgdHlwZSwgaXQgcmV0dXJuZWQgYCArIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpXG4gICAgKTtcbiAgfVxuICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgbGV0IGV2ZW50cyA9IFtdO1xuICBjb25zdCBvbkV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgZXZlbnRzLnB1c2goZXZlbnQpO1xuICB9O1xuICBjb25zdCBvbkNodW5rID0gZ2V0TGluZXMoXG4gICAgZ2V0TWVzc2FnZXMoXG4gICAgICAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgfSxcbiAgICAgIG9uRXZlbnRcbiAgICApXG4gICk7XG4gIHRyeSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgb25DaHVuayh2YWx1ZSk7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmRhdGEgPT09IFwiW0RPTkVdXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIGRhdGEgIT09IG51bGwgJiYgXCJlcnJvclwiIGluIGRhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgeWllbGQgZGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXZlbnRzID0gW107XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICB9XG59XG5cbi8vIHNyYy9saWIvSW5mZXJlbmNlT3V0cHV0RXJyb3IudHNcbnZhciBJbmZlcmVuY2VPdXRwdXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKFxuICAgICAgYEludmFsaWQgaW5mZXJlbmNlIG91dHB1dDogJHttZXNzYWdlfS4gVXNlIHRoZSAncmVxdWVzdCcgbWV0aG9kIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycyB0byBkbyBhIGN1c3RvbSBjYWxsIHdpdGggbm8gdHlwZSBjaGVja2luZy5gXG4gICAgKTtcbiAgICB0aGlzLm5hbWUgPSBcIkluZmVyZW5jZU91dHB1dEVycm9yXCI7XG4gIH1cbn07XG5cbi8vIHNyYy90YXNrcy9hdWRpby9hdWRpb0NsYXNzaWZpY2F0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiBhdWRpb0NsYXNzaWZpY2F0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJhdWRpby1jbGFzc2lmaWNhdGlvblwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeSgoeCkgPT4gdHlwZW9mIHgubGFiZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHguc2NvcmUgPT09IFwibnVtYmVyXCIpO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7bGFiZWw6IHN0cmluZywgc2NvcmU6IG51bWJlcn0+XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9hdWRpby9hdXRvbWF0aWNTcGVlY2hSZWNvZ25pdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gYXV0b21hdGljU3BlZWNoUmVjb2duaXRpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcImF1dG9tYXRpYy1zcGVlY2gtcmVjb2duaXRpb25cIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IHR5cGVvZiByZXM/LnRleHQgPT09IFwic3RyaW5nXCI7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIHt0ZXh0OiBzdHJpbmd9XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9hdWRpby90ZXh0VG9TcGVlY2gudHNcbmFzeW5jIGZ1bmN0aW9uIHRleHRUb1NwZWVjaChhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwidGV4dC10by1zcGVlY2hcIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IHJlcyAmJiByZXMgaW5zdGFuY2VvZiBCbG9iO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBCbG9iXCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9hdWRpby9hdWRpb1RvQXVkaW8udHNcbmFzeW5jIGZ1bmN0aW9uIGF1ZGlvVG9BdWRpbyhhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwiYXVkaW8tdG8tYXVkaW9cIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoXG4gICAgKHgpID0+IHR5cGVvZiB4LmxhYmVsID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB4LmJsb2IgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHhbXCJjb250ZW50LXR5cGVcIl0gPT09IFwic3RyaW5nXCJcbiAgKTtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgQXJyYXk8e2xhYmVsOiBzdHJpbmcsIGJsb2I6IHN0cmluZywgY29udGVudC10eXBlOiBzdHJpbmd9PlwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvY3YvaW1hZ2VDbGFzc2lmaWNhdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gaW1hZ2VDbGFzc2lmaWNhdGlvbihhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwiaW1hZ2UtY2xhc3NpZmljYXRpb25cIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoKHgpID0+IHR5cGVvZiB4LmxhYmVsID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB4LnNjb3JlID09PSBcIm51bWJlclwiKTtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgQXJyYXk8e2xhYmVsOiBzdHJpbmcsIHNjb3JlOiBudW1iZXJ9PlwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvY3YvaW1hZ2VTZWdtZW50YXRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIGltYWdlU2VnbWVudGF0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJpbWFnZS1zZWdtZW50YXRpb25cIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoKHgpID0+IHR5cGVvZiB4LmxhYmVsID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB4Lm1hc2sgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHguc2NvcmUgPT09IFwibnVtYmVyXCIpO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7bGFiZWw6IHN0cmluZywgbWFzazogc3RyaW5nLCBzY29yZTogbnVtYmVyfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL2N2L2ltYWdlVG9UZXh0LnRzXG5hc3luYyBmdW5jdGlvbiBpbWFnZVRvVGV4dChhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IChhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcImltYWdlLXRvLXRleHRcIlxuICB9KSk/LlswXTtcbiAgaWYgKHR5cGVvZiByZXM/LmdlbmVyYXRlZF90ZXh0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQge2dlbmVyYXRlZF90ZXh0OiBzdHJpbmd9XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9jdi9vYmplY3REZXRlY3Rpb24udHNcbmFzeW5jIGZ1bmN0aW9uIG9iamVjdERldGVjdGlvbihhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwib2JqZWN0LWRldGVjdGlvblwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeShcbiAgICAoeCkgPT4gdHlwZW9mIHgubGFiZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHguc2NvcmUgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHguYm94LnhtaW4gPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHguYm94LnltaW4gPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHguYm94LnhtYXggPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHguYm94LnltYXggPT09IFwibnVtYmVyXCJcbiAgKTtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBBcnJheTx7bGFiZWw6c3RyaW5nOyBzY29yZTpudW1iZXI7IGJveDp7eG1pbjpudW1iZXI7IHltaW46bnVtYmVyOyB4bWF4Om51bWJlcjsgeW1heDpudW1iZXJ9fT5cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL2N2L3RleHRUb0ltYWdlLnRzXG5hc3luYyBmdW5jdGlvbiB0ZXh0VG9JbWFnZShhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwidGV4dC10by1pbWFnZVwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gcmVzICYmIHJlcyBpbnN0YW5jZW9mIEJsb2I7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEJsb2JcIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3V0aWxzL2Jhc2U2NEZyb21CeXRlcy50c1xuZnVuY3Rpb24gYmFzZTY0RnJvbUJ5dGVzKGFycikge1xuICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhcnIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgIGFyci5mb3JFYWNoKChieXRlKSA9PiB7XG4gICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKFwiXCIpKTtcbiAgfVxufVxuXG4vLyBzcmMvdGFza3MvY3YvaW1hZ2VUb0ltYWdlLnRzXG5hc3luYyBmdW5jdGlvbiBpbWFnZVRvSW1hZ2UoYXJncywgb3B0aW9ucykge1xuICBsZXQgcmVxQXJncztcbiAgaWYgKCFhcmdzLnBhcmFtZXRlcnMpIHtcbiAgICByZXFBcmdzID0ge1xuICAgICAgYWNjZXNzVG9rZW46IGFyZ3MuYWNjZXNzVG9rZW4sXG4gICAgICBtb2RlbDogYXJncy5tb2RlbCxcbiAgICAgIGRhdGE6IGFyZ3MuaW5wdXRzXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXFBcmdzID0ge1xuICAgICAgLi4uYXJncyxcbiAgICAgIGlucHV0czogYmFzZTY0RnJvbUJ5dGVzKFxuICAgICAgICBuZXcgVWludDhBcnJheShhcmdzLmlucHV0cyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gYXJncy5pbnB1dHMgOiBhd2FpdCBhcmdzLmlucHV0cy5hcnJheUJ1ZmZlcigpKVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChyZXFBcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJpbWFnZS10by1pbWFnZVwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gcmVzICYmIHJlcyBpbnN0YW5jZW9mIEJsb2I7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEJsb2JcIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL2N2L3plcm9TaG90SW1hZ2VDbGFzc2lmaWNhdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gemVyb1Nob3RJbWFnZUNsYXNzaWZpY2F0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVxQXJncyA9IHtcbiAgICAuLi5hcmdzLFxuICAgIGlucHV0czoge1xuICAgICAgaW1hZ2U6IGJhc2U2NEZyb21CeXRlcyhcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgYXJncy5pbnB1dHMuaW1hZ2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGFyZ3MuaW5wdXRzLmltYWdlIDogYXdhaXQgYXJncy5pbnB1dHMuaW1hZ2UuYXJyYXlCdWZmZXIoKVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9O1xuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KHJlcUFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcInplcm8tc2hvdC1pbWFnZS1jbGFzc2lmaWNhdGlvblwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeSgoeCkgPT4gdHlwZW9mIHgubGFiZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHguc2NvcmUgPT09IFwibnVtYmVyXCIpO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7bGFiZWw6IHN0cmluZywgc2NvcmU6IG51bWJlcn0+XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvZmVhdHVyZUV4dHJhY3Rpb24udHNcbmFzeW5jIGZ1bmN0aW9uIGZlYXR1cmVFeHRyYWN0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGVmYXVsdFRhc2sgPSBhcmdzLm1vZGVsID8gYXdhaXQgZ2V0RGVmYXVsdFRhc2soYXJncy5tb2RlbCwgYXJncy5hY2Nlc3NUb2tlbiwgb3B0aW9ucykgOiB2b2lkIDA7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwiZmVhdHVyZS1leHRyYWN0aW9uXCIsXG4gICAgLi4uZGVmYXVsdFRhc2sgPT09IFwic2VudGVuY2Utc2ltaWxhcml0eVwiICYmIHsgZm9yY2VUYXNrOiBcImZlYXR1cmUtZXh0cmFjdGlvblwiIH1cbiAgfSk7XG4gIGxldCBpc1ZhbGlkT3V0cHV0ID0gdHJ1ZTtcbiAgY29uc3QgaXNOdW1BcnJheVJlYyA9IChhcnIsIG1heERlcHRoLCBjdXJEZXB0aCA9IDApID0+IHtcbiAgICBpZiAoY3VyRGVwdGggPiBtYXhEZXB0aClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYXJyLmV2ZXJ5KCh4KSA9PiBBcnJheS5pc0FycmF5KHgpKSkge1xuICAgICAgcmV0dXJuIGFyci5ldmVyeSgoeCkgPT4gaXNOdW1BcnJheVJlYyh4LCBtYXhEZXB0aCwgY3VyRGVwdGggKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcnIuZXZlcnkoKHgpID0+IHR5cGVvZiB4ID09PSBcIm51bWJlclwiKTtcbiAgICB9XG4gIH07XG4gIGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgaXNOdW1BcnJheVJlYyhyZXMsIDMsIDApO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTxudW1iZXJbXVtdW10gfCBudW1iZXJbXVtdIHwgbnVtYmVyW10gfCBudW1iZXI+XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvZmlsbE1hc2sudHNcbmFzeW5jIGZ1bmN0aW9uIGZpbGxNYXNrKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJmaWxsLW1hc2tcIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoXG4gICAgKHgpID0+IHR5cGVvZiB4LnNjb3JlID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB4LnNlcXVlbmNlID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB4LnRva2VuID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB4LnRva2VuX3N0ciA9PT0gXCJzdHJpbmdcIlxuICApO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIEFycmF5PHtzY29yZTogbnVtYmVyLCBzZXF1ZW5jZTogc3RyaW5nLCB0b2tlbjogbnVtYmVyLCB0b2tlbl9zdHI6IHN0cmluZ30+XCJcbiAgICApO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvcXVlc3Rpb25BbnN3ZXJpbmcudHNcbmFzeW5jIGZ1bmN0aW9uIHF1ZXN0aW9uQW5zd2VyaW5nKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJxdWVzdGlvbi1hbnN3ZXJpbmdcIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IHR5cGVvZiByZXMgPT09IFwib2JqZWN0XCIgJiYgISFyZXMgJiYgdHlwZW9mIHJlcy5hbnN3ZXIgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJlcy5lbmQgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHJlcy5zY29yZSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgcmVzLnN0YXJ0ID09PSBcIm51bWJlclwiO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCB7YW5zd2VyOiBzdHJpbmcsIGVuZDogbnVtYmVyLCBzY29yZTogbnVtYmVyLCBzdGFydDogbnVtYmVyfVwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvbmxwL3NlbnRlbmNlU2ltaWxhcml0eS50c1xuYXN5bmMgZnVuY3Rpb24gc2VudGVuY2VTaW1pbGFyaXR5KGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGVmYXVsdFRhc2sgPSBhcmdzLm1vZGVsID8gYXdhaXQgZ2V0RGVmYXVsdFRhc2soYXJncy5tb2RlbCwgYXJncy5hY2Nlc3NUb2tlbiwgb3B0aW9ucykgOiB2b2lkIDA7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwic2VudGVuY2Utc2ltaWxhcml0eVwiLFxuICAgIC4uLmRlZmF1bHRUYXNrID09PSBcImZlYXR1cmUtZXh0cmFjdGlvblwiICYmIHsgZm9yY2VUYXNrOiBcInNlbnRlbmNlLXNpbWlsYXJpdHlcIiB9XG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeSgoeCkgPT4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIpO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBudW1iZXJbXVwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvbmxwL3N1bW1hcml6YXRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIHN1bW1hcml6YXRpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcInN1bW1hcml6YXRpb25cIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoKHgpID0+IHR5cGVvZiB4Py5zdW1tYXJ5X3RleHQgPT09IFwic3RyaW5nXCIpO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7c3VtbWFyeV90ZXh0OiBzdHJpbmd9PlwiKTtcbiAgfVxuICByZXR1cm4gcmVzPy5bMF07XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvdGFibGVRdWVzdGlvbkFuc3dlcmluZy50c1xuYXN5bmMgZnVuY3Rpb24gdGFibGVRdWVzdGlvbkFuc3dlcmluZyhhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwidGFibGUtcXVlc3Rpb24tYW5zd2VyaW5nXCJcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSB0eXBlb2YgcmVzPy5hZ2dyZWdhdG9yID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByZXMuYW5zd2VyID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkocmVzLmNlbGxzKSAmJiByZXMuY2VsbHMuZXZlcnkoKHgpID0+IHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKSAmJiBBcnJheS5pc0FycmF5KHJlcy5jb29yZGluYXRlcykgJiYgcmVzLmNvb3JkaW5hdGVzLmV2ZXJ5KChjb29yZCkgPT4gQXJyYXkuaXNBcnJheShjb29yZCkgJiYgY29vcmQuZXZlcnkoKHgpID0+IHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSk7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQge2FnZ3JlZ2F0b3I6IHN0cmluZywgYW5zd2VyOiBzdHJpbmcsIGNlbGxzOiBzdHJpbmdbXSwgY29vcmRpbmF0ZXM6IG51bWJlcltdW119XCJcbiAgICApO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvdGV4dENsYXNzaWZpY2F0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiB0ZXh0Q2xhc3NpZmljYXRpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSAoYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0ZXh0LWNsYXNzaWZpY2F0aW9uXCJcbiAgfSkpPy5bMF07XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KCh4KSA9PiB0eXBlb2YgeD8ubGFiZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHguc2NvcmUgPT09IFwibnVtYmVyXCIpO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7bGFiZWw6IHN0cmluZywgc2NvcmU6IG51bWJlcn0+XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy91dGlscy90b0FycmF5LnRzXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICByZXR1cm4gW29ial07XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvdGV4dEdlbmVyYXRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIHRleHRHZW5lcmF0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gdG9BcnJheShcbiAgICBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0YXNrSGludDogXCJ0ZXh0LWdlbmVyYXRpb25cIlxuICAgIH0pXG4gICk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KCh4KSA9PiB0eXBlb2YgeD8uZ2VuZXJhdGVkX3RleHQgPT09IFwic3RyaW5nXCIpO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7Z2VuZXJhdGVkX3RleHQ6IHN0cmluZ30+XCIpO1xuICB9XG4gIHJldHVybiByZXM/LlswXTtcbn1cblxuLy8gc3JjL3Rhc2tzL25scC90ZXh0R2VuZXJhdGlvblN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIHRleHRHZW5lcmF0aW9uU3RyZWFtKGFyZ3MsIG9wdGlvbnMpIHtcbiAgeWllbGQqIHN0cmVhbWluZ1JlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwidGV4dC1nZW5lcmF0aW9uXCJcbiAgfSk7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvdG9rZW5DbGFzc2lmaWNhdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gdG9rZW5DbGFzc2lmaWNhdGlvbihhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IHRvQXJyYXkoXG4gICAgYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdGFza0hpbnQ6IFwidG9rZW4tY2xhc3NpZmljYXRpb25cIlxuICAgIH0pXG4gICk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KFxuICAgICh4KSA9PiB0eXBlb2YgeC5lbmQgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHguZW50aXR5X2dyb3VwID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB4LnNjb3JlID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB4LnN0YXJ0ID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB4LndvcmQgPT09IFwic3RyaW5nXCJcbiAgKTtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBBcnJheTx7ZW5kOiBudW1iZXIsIGVudGl0eV9ncm91cDogc3RyaW5nLCBzY29yZTogbnVtYmVyLCBzdGFydDogbnVtYmVyLCB3b3JkOiBzdHJpbmd9PlwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvbmxwL3RyYW5zbGF0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiB0cmFuc2xhdGlvbihhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwidHJhbnNsYXRpb25cIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoKHgpID0+IHR5cGVvZiB4Py50cmFuc2xhdGlvbl90ZXh0ID09PSBcInN0cmluZ1wiKTtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgdHlwZSBBcnJheTx7dHJhbnNsYXRpb25fdGV4dDogc3RyaW5nfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcz8ubGVuZ3RoID09PSAxID8gcmVzPy5bMF0gOiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvemVyb1Nob3RDbGFzc2lmaWNhdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gemVyb1Nob3RDbGFzc2lmaWNhdGlvbihhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IHRvQXJyYXkoXG4gICAgYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdGFza0hpbnQ6IFwiemVyby1zaG90LWNsYXNzaWZpY2F0aW9uXCJcbiAgICB9KVxuICApO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeShcbiAgICAoeCkgPT4gQXJyYXkuaXNBcnJheSh4LmxhYmVscykgJiYgeC5sYWJlbHMuZXZlcnkoKF9sYWJlbCkgPT4gdHlwZW9mIF9sYWJlbCA9PT0gXCJzdHJpbmdcIikgJiYgQXJyYXkuaXNBcnJheSh4LnNjb3JlcykgJiYgeC5zY29yZXMuZXZlcnkoKF9zY29yZSkgPT4gdHlwZW9mIF9zY29yZSA9PT0gXCJudW1iZXJcIikgJiYgdHlwZW9mIHguc2VxdWVuY2UgPT09IFwic3RyaW5nXCJcbiAgKTtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgQXJyYXk8e2xhYmVsczogc3RyaW5nW10sIHNjb3JlczogbnVtYmVyW10sIHNlcXVlbmNlOiBzdHJpbmd9PlwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvbmxwL2NoYXRDb21wbGV0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiBjaGF0Q29tcGxldGlvbihhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwidGV4dC1nZW5lcmF0aW9uXCIsXG4gICAgY2hhdENvbXBsZXRpb246IHRydWVcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSB0eXBlb2YgcmVzID09PSBcIm9iamVjdFwiICYmIEFycmF5LmlzQXJyYXkocmVzPy5jaG9pY2VzKSAmJiB0eXBlb2YgcmVzPy5jcmVhdGVkID09PSBcIm51bWJlclwiICYmIHR5cGVvZiByZXM/LmlkID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByZXM/Lm1vZGVsID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByZXM/LnN5c3RlbV9maW5nZXJwcmludCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmVzPy51c2FnZSA9PT0gXCJvYmplY3RcIjtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgQ2hhdENvbXBsZXRpb25PdXRwdXRcIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL25scC9jaGF0Q29tcGxldGlvblN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIGNoYXRDb21wbGV0aW9uU3RyZWFtKGFyZ3MsIG9wdGlvbnMpIHtcbiAgeWllbGQqIHN0cmVhbWluZ1JlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwidGV4dC1nZW5lcmF0aW9uXCIsXG4gICAgY2hhdENvbXBsZXRpb246IHRydWVcbiAgfSk7XG59XG5cbi8vIHNyYy90YXNrcy9tdWx0aW1vZGFsL2RvY3VtZW50UXVlc3Rpb25BbnN3ZXJpbmcudHNcbmFzeW5jIGZ1bmN0aW9uIGRvY3VtZW50UXVlc3Rpb25BbnN3ZXJpbmcoYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXFBcmdzID0ge1xuICAgIC4uLmFyZ3MsXG4gICAgaW5wdXRzOiB7XG4gICAgICBxdWVzdGlvbjogYXJncy5pbnB1dHMucXVlc3Rpb24sXG4gICAgICAvLyBjb252ZXJ0IEJsb2Igb3IgQXJyYXlCdWZmZXIgdG8gYmFzZTY0XG4gICAgICBpbWFnZTogYmFzZTY0RnJvbUJ5dGVzKFxuICAgICAgICBuZXcgVWludDhBcnJheShcbiAgICAgICAgICBhcmdzLmlucHV0cy5pbWFnZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gYXJncy5pbnB1dHMuaW1hZ2UgOiBhd2FpdCBhcmdzLmlucHV0cy5pbWFnZS5hcnJheUJ1ZmZlcigpXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlcyA9IHRvQXJyYXkoXG4gICAgYXdhaXQgcmVxdWVzdChyZXFBcmdzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdGFza0hpbnQ6IFwiZG9jdW1lbnQtcXVlc3Rpb24tYW5zd2VyaW5nXCJcbiAgICB9KVxuICApPy5bMF07XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSB0eXBlb2YgcmVzPy5hbnN3ZXIgPT09IFwic3RyaW5nXCIgJiYgKHR5cGVvZiByZXMuZW5kID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiByZXMuZW5kID09PSBcInVuZGVmaW5lZFwiKSAmJiAodHlwZW9mIHJlcy5zY29yZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgcmVzLnNjb3JlID09PSBcInVuZGVmaW5lZFwiKSAmJiAodHlwZW9mIHJlcy5zdGFydCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgcmVzLnN0YXJ0ID09PSBcInVuZGVmaW5lZFwiKTtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgQXJyYXk8e2Fuc3dlcjogc3RyaW5nLCBlbmQ/OiBudW1iZXIsIHNjb3JlPzogbnVtYmVyLCBzdGFydD86IG51bWJlcn0+XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9tdWx0aW1vZGFsL3Zpc3VhbFF1ZXN0aW9uQW5zd2VyaW5nLnRzXG5hc3luYyBmdW5jdGlvbiB2aXN1YWxRdWVzdGlvbkFuc3dlcmluZyhhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcUFyZ3MgPSB7XG4gICAgLi4uYXJncyxcbiAgICBpbnB1dHM6IHtcbiAgICAgIHF1ZXN0aW9uOiBhcmdzLmlucHV0cy5xdWVzdGlvbixcbiAgICAgIC8vIGNvbnZlcnQgQmxvYiBvciBBcnJheUJ1ZmZlciB0byBiYXNlNjRcbiAgICAgIGltYWdlOiBiYXNlNjRGcm9tQnl0ZXMoXG4gICAgICAgIG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgIGFyZ3MuaW5wdXRzLmltYWdlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBhcmdzLmlucHV0cy5pbWFnZSA6IGF3YWl0IGFyZ3MuaW5wdXRzLmltYWdlLmFycmF5QnVmZmVyKClcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVzID0gKGF3YWl0IHJlcXVlc3QocmVxQXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwidmlzdWFsLXF1ZXN0aW9uLWFuc3dlcmluZ1wiXG4gIH0pKT8uWzBdO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gdHlwZW9mIHJlcz8uYW5zd2VyID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByZXMuc2NvcmUgPT09IFwibnVtYmVyXCI7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PHthbnN3ZXI6IHN0cmluZywgc2NvcmU6IG51bWJlcn0+XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy90YWJ1bGFyL3RhYnVsYXJSZWdyZXNzaW9uLnRzXG5hc3luYyBmdW5jdGlvbiB0YWJ1bGFyUmVncmVzc2lvbihhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwidGFidWxhci1yZWdyZXNzaW9uXCJcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KCh4KSA9PiB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIG51bWJlcltdXCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy90YWJ1bGFyL3RhYnVsYXJDbGFzc2lmaWNhdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gdGFidWxhckNsYXNzaWZpY2F0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0YWJ1bGFyLWNsYXNzaWZpY2F0aW9uXCJcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KCh4KSA9PiB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIG51bWJlcltdXCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy9IZkluZmVyZW5jZS50c1xudmFyIEhmSW5mZXJlbmNlID0gY2xhc3Mge1xuICBhY2Nlc3NUb2tlbjtcbiAgZGVmYXVsdE9wdGlvbnM7XG4gIGNvbnN0cnVjdG9yKGFjY2Vzc1Rva2VuID0gXCJcIiwgZGVmYXVsdE9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgZm5dIG9mIE9iamVjdC5lbnRyaWVzKHRhc2tzX2V4cG9ydHMpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IChwYXJhbXMsIG9wdGlvbnMpID0+IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIGZuKHsgLi4ucGFyYW1zLCBhY2Nlc3NUb2tlbiB9LCB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH0pXG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBjb3B5IG9mIEhmSW5mZXJlbmNlIHRpZWQgdG8gYSBzcGVjaWZpZWQgZW5kcG9pbnQuXG4gICAqL1xuICBlbmRwb2ludChlbmRwb2ludFVybCkge1xuICAgIHJldHVybiBuZXcgSGZJbmZlcmVuY2VFbmRwb2ludChlbmRwb2ludFVybCwgdGhpcy5hY2Nlc3NUb2tlbiwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gIH1cbn07XG52YXIgSGZJbmZlcmVuY2VFbmRwb2ludCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZW5kcG9pbnRVcmwsIGFjY2Vzc1Rva2VuID0gXCJcIiwgZGVmYXVsdE9wdGlvbnMgPSB7fSkge1xuICAgIGFjY2Vzc1Rva2VuO1xuICAgIGRlZmF1bHRPcHRpb25zO1xuICAgIGZvciAoY29uc3QgW25hbWUsIGZuXSBvZiBPYmplY3QuZW50cmllcyh0YXNrc19leHBvcnRzKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiAocGFyYW1zLCBvcHRpb25zKSA9PiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICBmbih7IC4uLnBhcmFtcywgYWNjZXNzVG9rZW4sIGVuZHBvaW50VXJsIH0sIHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfSlcbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuZXhwb3J0IHtcbiAgSGZJbmZlcmVuY2UsXG4gIEhmSW5mZXJlbmNlRW5kcG9pbnQsXG4gIEluZmVyZW5jZU91dHB1dEVycm9yLFxuICBhdWRpb0NsYXNzaWZpY2F0aW9uLFxuICBhdWRpb1RvQXVkaW8sXG4gIGF1dG9tYXRpY1NwZWVjaFJlY29nbml0aW9uLFxuICBjaGF0Q29tcGxldGlvbixcbiAgY2hhdENvbXBsZXRpb25TdHJlYW0sXG4gIGRvY3VtZW50UXVlc3Rpb25BbnN3ZXJpbmcsXG4gIGZlYXR1cmVFeHRyYWN0aW9uLFxuICBmaWxsTWFzayxcbiAgaW1hZ2VDbGFzc2lmaWNhdGlvbixcbiAgaW1hZ2VTZWdtZW50YXRpb24sXG4gIGltYWdlVG9JbWFnZSxcbiAgaW1hZ2VUb1RleHQsXG4gIG9iamVjdERldGVjdGlvbixcbiAgcXVlc3Rpb25BbnN3ZXJpbmcsXG4gIHJlcXVlc3QsXG4gIHNlbnRlbmNlU2ltaWxhcml0eSxcbiAgc3RyZWFtaW5nUmVxdWVzdCxcbiAgc3VtbWFyaXphdGlvbixcbiAgdGFibGVRdWVzdGlvbkFuc3dlcmluZyxcbiAgdGFidWxhckNsYXNzaWZpY2F0aW9uLFxuICB0YWJ1bGFyUmVncmVzc2lvbixcbiAgdGV4dENsYXNzaWZpY2F0aW9uLFxuICB0ZXh0R2VuZXJhdGlvbixcbiAgdGV4dEdlbmVyYXRpb25TdHJlYW0sXG4gIHRleHRUb0ltYWdlLFxuICB0ZXh0VG9TcGVlY2gsXG4gIHRva2VuQ2xhc3NpZmljYXRpb24sXG4gIHRyYW5zbGF0aW9uLFxuICB2aXN1YWxRdWVzdGlvbkFuc3dlcmluZyxcbiAgemVyb1Nob3RDbGFzc2lmaWNhdGlvbixcbiAgemVyb1Nob3RJbWFnZUNsYXNzaWZpY2F0aW9uXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@huggingface/inference/dist/index.js\n");

/***/ })

};
;